---
layout: "@/layouts/BlogPost.astro"
title: "JavaScript Code Transformation for a Niche Environment"
pubDate: "Sep 30 2022"
---

There is a game called [hackmud](https://store.steampowered.com/app/469920/hackmud/).
hackmud is a game where you solve puzzles and then automate them with JavaScript code for the collection of resources and power. The thing that most interests me about hackmud is not its gameplay, but its JS environment, due to how weird it is. This environment features custom preprocessor syntax and missing features due to security reasons. One of the weirder things about this environment is that code runs in a modern up-to-date v8 runtime, but the code is parsed through [Esprima](https://esprima.org/), an old [ES2015](https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_%E2%80%93_ECMAScript_2015) parser. This means, for example, we have access to the [`BigInt()` constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt/BigInt) but not [BigInt literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#bigint_type) (e.g. `3n`). This makes current JavaScript tooling useless for writing hackmud scripts, so I wrote my own. Another interesting thing to note is that in the beginning you're only allowed to upload one script to the game that is at most 500 chars. You must collect upgrades in the game to gain the ability to upload bigger and more scripts.

Each hackmud script is a standalone function expression that nothing can be outside of. Some of the preprocessor syntax includes a way to run other hackmud scripts (including other players') (`#fs.foo.bar()`) called subscripts, a per script global object that persists between subscript runs (`#G`), and a way to access a database that persists between script runs (`#db.f()`).

2 years ago I started a project called [Hackmud Script Manager](https://github.com/samualtnorman/hackmud-script-manager). This project was originally based on an old project called `hackmud_env-tools` (now lost to time) which itself was just the [tools](https://github.com/Snazzah/hackmud_env/tree/master/tools) pulled out from [Snazzah](https://github.com/Snazzah)'s project [`hackmud_env`](https://github.com/Snazzah/hackmud_env). Before this, I'd also developed a tool myself (which is even more lost to time) but I scrapped it when Snazzah released `hackmud_env` since mine was lacking features in comparison.

Hackmud Script Manager is a tool that can take in JavaScript or TypeScript code and spit out ES2015 code. It also supports minification, nicer global variables, general fixes, and even importing [NPM](https://www.npmjs.com/) packages.

## Hereâ€™s How That Process Works

I have a function called [`processScript()`](https://github.com/samualtnorman/hackmud-script-manager/blob/50a29edd5cec6e61a3829d2a48c1c250e0420f93/src/processScript/index.ts#L77). This function receives source code, and one of the first things it does is hand it off to [Rollup](https://rollupjs.org/guide/en/#overview) with a few plugins. One of these plugins is a custom one that converts the hackmud preprocessor syntax into valid JavaScript syntax.

This is done in a function called [`preprocess()`](https://github.com/samualtnorman/hackmud-script-manager/blob/50a29edd5cec6e61a3829d2a48c1c250e0420f93/src/processScript/preprocess.ts#L20). It mainly does this via brute force using [Babel](https://babeljs.io/) to continually attempt to parse the code catching `SyntaxError`s and replacing the invalid code with valid code until eventually, the script parses successfully. This process used to be done by a faster but dumber series of `.replace()`s but a downside was that it was overaggressive and replaced code it shouldn't have.

The babel plugin is used for converting modern syntax to ES2015 syntax. And a few other plugins are used for importing packages in scripts. Rollup then spits out a bundled up module and it is [`transform()`](https://github.com/samualtnorman/hackmud-script-manager/blob/50a29edd5cec6e61a3829d2a48c1c250e0420f93/src/processScript/transform.ts#L48)'s job to turn that into a single function expression. `transform()` finds and moves everything at the top level (except the `default` export) into a newly created (currently parentless) block statement. The `default` export acts as the main function (the function expression itself). We then iterate through the body of this parentless block statement in reverse.

When we find a declaration, we check if it is referenced outside of the block statement, if so we replace the declaration with an assignment to a property on the per script global object (`$G`) as well as replace references to the variable with references to that property. Then at the end, we insert the block statement with a guard that'll make sure the block will only run once.

hackmud is missing `this` due to legacy security reasons and trying to transform references to `this` with something equivalent is very difficult. Currently, Hackmud Script Manager only replaces references to `this` with something equivalent in classes. In the constructor `super()` returns the `this` value so we save that to a variable and replace references to `this` with references to the variable. In the class methods, assuming it hasn't been overridden, `super.valueOf()` returns the `this` value so we do the same with that. At the moment all other references to `this` are just replaced with `undefined` although this is temporary until I find workarounds for those cases as well.

If there were exports (excluding the `default` one), a `return` statement returning an object of the `exports` is appended to the end of the body of the main function. We also replace BigInt literals with calls to `BigInt()`.

Next is the minification step which is handled by [`minify()`](https://github.com/samualtnorman/hackmud-script-manager/blob/50a29edd5cec6e61a3829d2a48c1c250e0420f93/src/processScript/minify.ts#L39). hackmud has some custom global constants which have aliases that are shorter so it swaps out those for the shorter ones (e.g. `_TIMEOUT` to `_TO`). We also create aliases for globals and replace references to the globals with the created aliases so the name can be shortened. Next is where we can potentially cut down a large amount on the character count. For some reason, hackmud doesn't count comments towards the character count and scripts also have a way of accessing their own source code (`#fs.scripts.quine()`). This combined means we can serialize a lot of data in our script to JSON at compile time and then read it back with `JSON.parse()` at runtime. And there's no measurable slowdown that I could find. This may be because JSON is simpler to parse than JavaScript so, in theory, this might even save time. Data that can be stored as JSON includes strings, numbers, and global objects and arrays. If we turn dot notation into index notation (`foo.bar` to `foo["bar"]`), we can even save and store the names of properties to the JSON comment (the same goes towards object keys as well). We can also transform template strings into regular string concatenation and do the same with that. After that, we hand off the code to [terser](https://terser.org/) to make the general non-hackmud-specific optimisations.

Then we do some postprocessing to undo the preprocessing and regenerate hackmud's preprocessor syntax and we are done.
